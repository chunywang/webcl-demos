<!--
    Based on: http://www.ibiblio.org/e-notes/webcl/schrodinger_buf.html
-->
<html><head>
<TITLE>Schr&ouml;dinger equation</TITLE>

<script src="../common/gl.js" type="text/javascript"></script>
<script src="../common/webcl.js" type="text/javascript"></script>

<script id="clProgram" type="text/x-opencl">

constant int n = 256, m = 255, sh = 8;

__kernel void kRelax(global float2* in0, global float2* in2,
    global float2* outp, float cx, float cy){
  int x = get_global_id(0),  y = get_global_id(1),  ny = y<<sh;
  if (x >= m || y >= m) return;
  float2 t = in2[x + ny] + in0[x + 1 + ny] + in0[x - 1 + ny] +
    in0[x + ((y + 1)<<sh)] + in0[x + ((y - 1)<<sh)];
  outp[x + ny] = (float2)(cx*t.x - cy*t.y, cy*t.x + cx*t.y);
}

__kernel void kRelax2(global float2* inp,
    global float2* out2, float b){
  int x = get_global_id(0),  y = get_global_id(1),  ny = y<<sh;
  if (x >= m || y >= m) return;
  float2 u = inp[x + ny];
  out2[x + ny] =  b*(float2)(-u.y, u.x) - 4.0f*u +
    inp[x + 1 + ny] + inp[x - 1 + ny] +
    inp[x + ((y + 1)<<sh)] + inp[x + ((y - 1)<<sh)];
}

float fclamp(float x){ return fmin( fmax( 0.0f, x), 1.0f ); }

__kernel void kShow(global float2* inp, __global uchar4* col ){
  int adr = get_global_id(0) + (get_global_id(1) <<sh);
  float2 t = inp[adr];
  float c = fmin( dot(t,t), 255.0f);
  float a = atan2(t.y, t.x)*0.955f + 3.0f;
  col[adr] = (uchar4)(
    (uchar)(c*fclamp(fabs(a - 3.0f) - 1.0f)),
    (uchar)(c*fclamp(2.0f - fabs(a - 2.0f))),
    (uchar)(c*fclamp(2.0f - fabs(a - 4.0f))),
    (uchar)(255u) );
}
</script>
 
<script type="text/javascript"> 

function loadKernel ( id ){
   var shaderScript = document.getElementById ( id );
   var str = "";
   var k = shaderScript.firstChild;
   while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
   }
   return str;
}

var types = WebCLKernelArgumentTypes;
window.WebCL = webcl;
var useGPU = true;

var n = 256, n2 = n-2, kRelax, kRelax2, kShow, cmdQueue, b0, b1, ev,
  data, bufPix, outBuffer, bufferSize = 4*n*n, b2,
  delay = 0, it = 10, frames = 0, time, animation,
  phi = 0, ka = 50, kernelSrc, frTimer;
function CL_prog() {

  initDataBuffer();
  kernelSrc = loadKernel("clProgram");
  initWebCL();

  var canvas = document.getElementById("c");
  init_gl(canvas, true);
  outBuffer = new Uint8Array(bufferSize*2);
  frTimer = setInterval(fr, 500);
  time = new Date().getTime();
  animation = "animate";
  anim();
}

function initWebCL() {
  var output = document.getElementById("output");
  output.innerHTML = "";

  try {
    WebCLCommon.init(useGPU ? "GPU" : "CPU");
    var context = WebCLCommon.createContext();
    var program = WebCLCommon.createProgramBuild(kernelSrc);
    if(cmdQueue) {
      cmdQueue.finish();
    }
    cmdQueue = WebCLCommon.createCommandQueue();

    b0 = context.createBuffer(WebCL.MEM_READ_WRITE, bufferSize*2);
    b1 = context.createBuffer(WebCL.MEM_READ_WRITE, bufferSize*2);
    b2 = context.createBuffer(WebCL.MEM_READ_WRITE, bufferSize*2);

    kRelax = program.createKernel("kRelax");
    kRelax.setArg(0, b0);
    kRelax.setArg(1, b2);
    kRelax.setArg(2, b1);

    var dth2 = .5, t = 16 + 4/(dth2*dth2);
    kRelax.setArg(3, 4/t, types.FLOAT);
    kRelax.setArg(4, 2/(dth2*t), types.FLOAT);

    kRelax2 = program.createKernel("kRelax2");
    kRelax2.setArg(0, b0);
    kRelax2.setArg(1, b2);
    kRelax2.setArg(2, -2/dth2, types.FLOAT);

    bufPix = context.createBuffer(WebCL.MEM_WRITE_ONLY, bufferSize);
    kShow = program.createKernel("kShow");
    kShow.setArg(0, b0);
    kShow.setArg(1, bufPix);

    ev = cmdQueue.enqueueWriteBuffer(b0, true, 0, bufferSize*2, data);

  } catch(e) {
    document.getElementById("output").innerHTML
      += "<h3>ERROR:</h3><pre style=\"color:red;\">" + e.message + "</pre>";
  }
}

function initDataBuffer() {
  data = new Float32Array( bufferSize/2 );
  var cp = Math.cos(phi), sp = Math.sin(phi);
  var t = 0, h = 1/n;
  for(var i = 0; i < n; i++)
    for(var j = 0; j < n; j++){
     var x = h*(j - n/2),  y = h*(i - n/2);
     var exp = 16*Math.exp(-20*(x*x + y*y));
     data[t++] = exp*Math.cos(ka*(cp*x + sp*y));
     data[t++] = exp*Math.sin(ka*(cp*x + sp*y));
    }
}
var globalWorkSize = new Int32Array([n,n]);
var localWorkSize = new Int32Array([8,8]);
var globalWorkOffset = new Int32Array([1,1]);

function draw() {
  for(var j = 0; j < 4; j++){
    ev = cmdQueue.enqueueNDRangeKernel(kRelax2, globalWorkOffset, globalWorkSize, null);
    cmdQueue.flush();

    for(var i = 0; i < it; i++){
      kRelax.setArg(0, b0);
      kRelax.setArg(2, b1);
      ev = cmdQueue.enqueueNDRangeKernel(kRelax, globalWorkOffset, globalWorkSize, null);
      cmdQueue.flush();

      kRelax.setArg(0, b1);
      kRelax.setArg(2, b0);
      ev = cmdQueue.enqueueNDRangeKernel(kRelax, globalWorkOffset, globalWorkSize, null);
      cmdQueue.flush();
    }
  }
  cmdQueue.enqueueNDRangeKernel(kShow, globalWorkOffset, globalWorkSize, null);
  cmdQueue.flush();
  cmdQueue.enqueueReadBuffer(bufPix, true, 0, bufferSize, outBuffer);
  draw_gl(n, n, outBuffer);
  frames++;
}

function anim() {
   draw();
   switch ( animation ){
     case "reset":
      var cp = Math.cos(phi), sp = Math.sin(phi);
      var t = 0, h = 1/n;
      for(var i = 0; i < n; i++)
        for(var j = 0; j < n; j++){
         var x = h*(j - n/2),  y = h*(i - n/2);
         var exp = 16*Math.exp(-20*(x*x + y*y));
         data[t++] = exp*Math.cos(ka*(cp*x + sp*y));
         data[t++] = exp*Math.sin(ka*(cp*x + sp*y));
        }
      cmdQueue.enqueueWriteBuffer(b0, true, 0, bufferSize*2, data);
      animation = "animate";
     case "animate":
       if (delay == 0) requestAnimationFrame(anim);
       else setTimeout("requestAnimationFrame(anim)", delay);
       break;
     case "stop":
       break;
   }
}

function run(v) {
  if( animation == "animate" ){
    animation = "stop";
    document.getElementById('runBtn').value = "Run ";}
  else{
    animation = "animate";
    document.getElementById('runBtn').value = "Stop";
    anim();
  }
}

function reset() {
  if( animation == "stop" ){
    animation = "reset";
    document.getElementById('runBtn').value = "Stop";
    anim();}
  else animation = "reset";
}

function fr() {
  var ti = new Date().getTime();
  var fps = Math.round(1000*frames/(ti - time));
  document.getElementById("framerate").value = fps;
  frames = 0;  time = ti;
}

function setPhi(v) {
  phi = v.valueOf() *Math.PI/180;
}

function setK(v) {
  ka = v.valueOf();
}

function setDt(v) {
  var dth2 = v.valueOf();
  var t = 16 + 4/(dth2*dth2);
  kRelax.setArg(3, 4/t, types.FLOAT);
  kRelax.setArg(4, 2/(dth2*t), types.FLOAT);
  kRelax2.setArg(2, -2/dth2, types.FLOAT);
}

function setDelay(val) {
  delay = parseInt(val);
}

function switchDevice() {
  window.clearInterval(frTimer);
  initWebCL();
}
</script> 
<style type="text/css">
  H1{ font-size: 120%; color: green}
  H2{ font-size: 100%; color: green}
  pre{ color: darkblue}
</style>
</head>
<body onload="CL_prog()"> 

<p id="output"></p>

<canvas id="c" width="512" height="512" ></canvas>
<br><button onclick="reset()">Reset</button>
<input type="button" onclick="run()" value="Stop" size="1" id="runBtn">
K<input size="2" value="50" onchange="setK( this.value )">
&phi;&deg;<input size="2" value="0" onchange="setPhi( this.value )">
&Delta;t/h<sup>2</sup><input size="2" value="0.5" onchange="setDt( this.value )">
delay<input size="2" value="0" onchange="setDelay( this.value )">
fps<input size="2" id="framerate">
<br>
Device:
<input type="radio" name="device" id="GPUradio" onclick="useGPU=true;switchDevice()" checked="true">GPU
<input type="radio" name="device" id="CPUradio" onclick="useGPU=false;switchDevice()">CPU

</body></html>