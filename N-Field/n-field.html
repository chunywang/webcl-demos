<!--
    Based on: http://www.ibiblio.org/e-notes/webcl/mc/n-field.html
-->

<html><head>
<TITLE>n-field model</TITLE>

<script src="cl_gl.js" type="text/javascript"></script>

<script id="clN" type="text/x-opencl">

constant int n = 512;
constant float h = 1.0f/512.0f, del = .1f;

__kernel void kSpin(read_only image2d_t s, global uint* rand,
  write_only image2d_t s1, int bw, float rT ) {
  const sampler_t samp =
    CLK_NORMALIZED_COORDS_TRUE|CLK_ADDRESS_REPEAT|CLK_FILTER_NEAREST;
  int ix = get_global_id(0),  iy = get_global_id(1),  t = ix + n*iy;
  float x = h*(ix + .5f),  y = h*(iy + .5f);
  float3 s0 = read_imagef(s, samp, (float2)(x, y)).xyz;
  float3 snew = s0;
  if ( ((ix + iy) % 2) == bw){
    uint r = 1664525u * rand[t] + 1013904223u;
    float3 v1 = fast_normalize( (float3)(s0.y, -s0.x, 0.0f) );
    float3 v2 = cross(s0, v1)*(r/4294967295.0f - .5f)*del;
    r = 1664525u * r + 1013904223u;
    v1 = v1*(r/4294967295.0f - .5f)*del;
    r = 1664525u * r + 1013904223u;
    rand[t] = r;
    snew = fast_normalize(s0 + v1 + v2);
    v1 = snew - s0;
    float en = -dot(read_imagef(s, samp, (float2)(x + h, y)).xyz, v1);
    en -= dot(read_imagef(s, samp, (float2)(x - h, y)).xyz, v1);
    en -= dot(read_imagef(s, samp, (float2)(x, y + h)).xyz, v1);
    en -= dot(read_imagef(s, samp, (float2)(x, y - h)).xyz, v1);
    if (r > 4294967295.0f*native_exp(-en*rT)) snew = s0;
  }
  write_imagef(s1, (int2)(ix, iy), (float4)(snew, 0.0f) );
}

float fclamp(float x){ return fmin( fmax( 0.0f, x), 1.0f ); }

__kernel void kPix(read_only image2d_t s, global uchar4* pix) {
  const sampler_t samp =
    CLK_NORMALIZED_COORDS_FALSE|CLK_ADDRESS_CLAMP|CLK_FILTER_NEAREST;
  int x = get_global_id(0),  y = get_global_id(1);
  float3 t = read_imagef(s, samp, (int2)(x, y)).xyz;
  float a = 255.0f*fmin( t.z + 1.0f, 1.0f);
  float w = 255.0f*fmax( t.z, 0.0f);
  float c = atan2(t.y, t.x)*0.955f + 3.0f;
  pix[y*n + x] = (uchar4)(
    (uchar)fmin(a*fclamp(fabs(c - 3.0f) - 1.0f) + w, 255.0f),
    (uchar)fmin(a*fclamp(2.0f - fabs(c - 2.0f)) + w, 255.0f),
    (uchar)fmin(a*fclamp(2.0f - fabs(c - 4.0f)) + w, 255.0f),
    255 );
}
</script>

<script type="text/javascript">

function loadKernel ( id ){
   var shaderScript = document.getElementById ( id );
   var str = "";
   var k = shaderScript.firstChild;
   while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
   }
   return str;
}

var T = 0.01, n = 512, it = 100, delay = 0, bufSize = 4*n*n,
    ctx_c, frames = 0, animation = "animate", time;
var kSpin, kPix, cmdQueue, ev, iSpin, iSpin1, bufPix, outBuffer;

var bufRand;

function CL_rand () {
  try {
    if (window.WebCL == undefined) {
      alert("Unfortunately your system does not support WebCL");
      return false;
    }
    var platforms = WebCL.getPlatformIDs();
    var ctx = WebCL.createContextFromType ([WebCL.CL_CONTEXT_PLATFORM,
       platforms[0]], WebCL.CL_DEVICE_TYPE_CPU);
    var devices = ctx.getContextInfo(WebCL.CL_CONTEXT_DEVICES);
    var format = {channelOrder:WebCL.CL_RGBA, channelDataType:WebCL.CL_FLOAT};

    bufRand = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4*n*n);
    iSpin  = ctx.createImage2D(WebCL.CL_MEM_READ_WRITE, format, n, n, 0);
    iSpin1 = ctx.createImage2D(WebCL.CL_MEM_READ_WRITE, format, n, n, 0);
    bufPix  = ctx.createBuffer (WebCL.CL_MEM_WRITE_ONLY, 4*n*n);

    var kernelSrc = loadKernel("clN");
    var program = ctx.createProgramWithSource(kernelSrc);
    try {
      program.buildProgram ([devices[0]], "");
    } catch(e) {
        alert(e.message);
      alert ("Failed to build WebCL program. Error "
        + program.getProgramBuildInfo (devices[0],
           WebCL.CL_PROGRAM_BUILD_STATUS)
        + ":  " + program.getProgramBuildInfo (devices[0],
           WebCL.CL_PROGRAM_BUILD_LOG));
      throw e;
    }
    kSpin = program.createKernel ("kSpin");
    kSpin.setKernelArg (1, bufRand);
    kSpin.setKernelArg (4, 1/T, WebCL.types.FLOAT);
    kPix = program.createKernel("kPix");
    kPix.setKernelArg(0, iSpin);
    kPix.setKernelArg(1, bufPix);

    cmdQueue = ctx.createCommandQueue (devices[0], 0);
    var UIrand = new Uint32Array(n*n);
    for ( var i = 0; i < n*n;  i++ )
      UIrand[i] = Math.floor(Math.random() * 4294967295);
    var spin = new Float32Array(4*n*n),  p = 0;
    for ( var i = 0; i < n*n;  i++ ){
      var x = Math.random()-.5, y = Math.random()-.5, z = Math.random()-.5;
      var no = (Math.sqrt(x*x+y*y+z*z));
      spin[p++] = x/no;  spin[p++] = y/no;  spin[p++] = z/no;  spin[p++] = 0;
    }
    cmdQueue.enqueueWriteImage(iSpin, true, [0,0,0], [n,n,1], 0, 0, spin, []);
    ev = cmdQueue.enqueueWriteBuffer(bufRand, true, 0, 4*n*n, UIrand, []);
    outBuffer = new Uint8Array(4*n*n);
  } catch(e) {
    document.getElementById("output").innerHTML
      += "<h3>ERROR:</h3><pre style=\"color:red;\">" + e.message + "</pre>";
    throw e;
  }
  var canvas = document.getElementById("c");
  init_gl(canvas);
  time = new Date().getTime();
  setInterval(fr, 500);
  anim();
}

function draw(){
  for ( var i = 0; i < it;  i++ ){
   kSpin.setKernelArg(0, iSpin);
   kSpin.setKernelArg(2, iSpin1);
   kSpin.setKernelArg(3, 0, WebCL.types.INT);
   ev = cmdQueue.enqueueNDRangeKernel(kSpin, 2, [], [n,n], [], [ev]);
   cmdQueue.flush();

   kSpin.setKernelArg(0, iSpin1);
   kSpin.setKernelArg(2, iSpin);
   kSpin.setKernelArg(3, 1, WebCL.types.INT);
   ev = cmdQueue.enqueueNDRangeKernel(kSpin, 2, [], [n,n], [], [ev]);
   cmdQueue.flush();
  }
  ev = cmdQueue.enqueueNDRangeKernel(kPix, 2, [], [n,n], [], [ev]);
  cmdQueue.enqueueReadBuffer (bufPix, true, 0, bufSize, outBuffer, [ev]);
  draw_gl(n, n, outBuffer);
  frames++;
}

function anim(){
   draw();
   switch ( animation ){
     case "reset":
      var spin = new Float32Array(4*n*n),  p = 0;
      for ( var i = 0; i < n*n;  i++ ){
        var x = Math.random()-.5, y = Math.random()-.5, z = Math.random()-.5;
        var no = (Math.sqrt(x*x+y*y+z*z));
        spin[p++] = x/no;  spin[p++] = y/no;  spin[p++] = z/no;  spin[p++] = 0;
      }
      cmdQueue.enqueueWriteImage(iSpin, true, [0,0,0],[n,n,1],0,0, spin, []);
      animation = "animate";
     case "animate":
       if (delay == 0) requestAnimFrame(anim);
       else setTimeout("requestAnimFrame(anim)", delay);
       break;
     case "stop":
       break;
   }
}

function run(v) {
  if( animation == "animate" ){
    animation = "stop";
    document.getElementById('runBtn').value = "Run ";}
  else{
    animation = "animate";
    document.getElementById('runBtn').value = "Stop";
    anim();
  }
}

function reset() {
  if( animation == "stop" ){
    animation = "reset";
    document.getElementById('runBtn').value = "Stop";
    anim();}
  else animation = "reset";
}

function setDelay(val) {
  delay = parseInt(val);
}

function fr(){
  var ti = new Date().getTime();
  var fps = Math.round(1000*frames/(ti - time));
  document.getElementById("framerate").value = fps;
  frames = 0;  time = ti;
}

function setT(v){
  var T = v.valueOf();
  kSpin.setKernelArg (4, 1/T, WebCL.types.FLOAT);
}

function setIt(val) {
  it = parseInt(val);
}

</script>

<style type="text/css">
  H1{ font-size: 120%; color: green}
  H2{ font-size: 100%; color: green}
  pre{ color: darkblue}
</style>
</head><body onload="CL_rand ()">

<h1>n-field model</h1>

<p id="output"></p>
<canvas id="c" width="512" height="512"></canvas>
<br><button onclick="reset()">Reset</button>
<input type="button" onclick="run()" value="Stop" size="1" id="runBtn">
T<input size="4" value="0.01" onchange="setT( this.value )">
It<input size="1" value="100" onchange="setIt( this.value )">
delay<input size="2" value="0" onchange="setDelay( this.value )">
fps<input size="2" id="framerate">

<br>GPU based Monte-Carlo simulation of the
<a href="../../Perc/inst.htm">n-field model</a> on the square 512&times;512 grid
(see also Fig.1 and <a href="../../webgl/models/ic.html">WebGL 3D instanton</a>).
<i>it</i> is the number of MC iterations per frame.
The linear congruential random number generator is used.
You can watch instantons formation from random spin configuration.
<br><img width="550" height="150" alt="anti-instanton" src="../../Perc/fig/instanton.gif">
<br>Below different HUE colors are used for different spin phases <i>&phi;</i>
(spin unit vector has coordinates <i><b>s</b> = (cos &phi; &middot;
 sin &theta;, sin &phi; &middot; sin &theta;, cos &theta;)</i> ).
"Top" spins (<i>&theta; = 0</i>) are white and "bottom" ones
(<i>&theta; = &pi;</i>) are black.
<br><img width="250" height="150" title="n-field" src="../fig/instanton_c.jpg">
<img width="250" height="150" title="n-field" src="../fig/n-field.jpg">
<br>Instantons (topological solitons) are looked as color round defects
in these pictures.

<hr><a href="../WebCL.htm">WebCL Demos</a>
&nbsp; &nbsp; <i>updated</i> 22 Sep 2011

</body></html>
