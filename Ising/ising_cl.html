<!--
    Based on http://www.ibiblio.org/e-notes/webcl/mc/ising_cl.html
-->

<html><head>
<TITLE>Ising model. Chess-board algorithm</TITLE>

<script src="../common/gl.js" type="text/javascript"></script>
<script src="../common/webcl.js" type="text/javascript"></script>

<script type="text/javascript">

var ctx_c, n = 512, it = 100, bufSize = 4*n*n, bufW, ev,
    frames = 0, animation = "animate", time, delay = 0;
var kSpin, kPix, cmdQueue, iSpin, iSpin1, bufRand, bufW, bufWSize=4*5, bufPix, outBuffer;
var types = WebCLKernelArgumentTypes;
var useGPU = false;

function CL_rand () {
  try {
    WebCLCommon.init(useGPU ? "GPU" : "CPU");
    var ctx = WebCLCommon.createContext();
    var kernelSrc = WebCLCommon.loadKernel("kernel.cl");
    if (!kernelSrc) {
        console.error("ERROR: could not load the kernel.");
        return;
    }
    var program = WebCLCommon.createProgramBuild(kernelSrc);

    cmdQueue = WebCLCommon.createCommandQueue();

    bufRand = ctx.createBuffer(webcl.MEM_READ_WRITE, bufSize);
    bufW = ctx.createBuffer(webcl.MEM_READ_ONLY, bufWSize);

    var descriptor = {channelOrder:webcl.RGBA, channelDataType:webcl.SIGNED_INT8,
                      width:n, height:n, rowPitch:0};
    iSpin  = ctx.createImage(webcl.MEM_READ_WRITE, descriptor);
    iSpin1 = ctx.createImage(webcl.MEM_READ_WRITE, descriptor);
    bufPix  = ctx.createBuffer(webcl.MEM_WRITE_ONLY, bufSize);

    initImageSpin();

    kSpin = program.createKernel("kSpin");
    kSpin.setArg(1, bufRand);
    kSpin.setArg(4, bufW);
    kPix = program.createKernel("kPix");
    kPix.setArg(0, iSpin);
    kPix.setArg(1, iSpin1);
    kPix.setArg(2, bufPix);

    var T = 1,  w = new Float32Array(5);
    for(var i = 0; i < 5; i++)
      w[i] = 4294967295/(1 + Math.exp(2*(2*i - 4)/T));
    cmdQueue.enqueueWriteBuffer(bufW, true, 0, bufWSize, w);

    var UIrand = new Uint32Array(n*n);
    for ( var i = 0; i < n*n;  i++ )
      UIrand[i] = Math.floor(Math.random() * 4294967295);
    cmdQueue.enqueueWriteBuffer(bufRand, true, 0, bufSize, UIrand);

    outBuffer = new Uint8Array(bufSize);

  } catch(e) {
    document.getElementById("output").innerHTML
      += "<h3>ERROR:</h3><pre style=\"color:red;\">" + e.message + "</pre>";
    throw e;
  }
  var canvas = document.getElementById("c");
  init_gl(canvas, false);
  time = new Date().getTime();
  setInterval(fr, 500);
  anim();
}

function initImageSpin() {
  var spin = new Int8Array(n*n);
  for ( var i = 0; i < n*n;  i++ )
    spin[i] = Math.floor(Math.random() * 1.999999);

  var origin = new Int32Array([0,0,0]);
  var region = new Int32Array([n,n,1]);
  var hostRowPitch = new Uint32Array([0]);

  cmdQueue.enqueueWriteImage(iSpin, true, origin, region, hostRowPitch, spin);
  cmdQueue.enqueueWriteImage(iSpin1, true, origin, region, hostRowPitch, spin);
}

var globalWorkSize = new Int32Array([n,n]);
function draw(){
  for ( var i = 0; i < it;  i++ ){
   kSpin.setArg(0, iSpin);
   kSpin.setArg(2, iSpin1);
   kSpin.setArg(3, 0, types.INT);
   cmdQueue.enqueueNDRangeKernel(kSpin, 0, globalWorkSize, null);
   cmdQueue.flush();

   kSpin.setArg(0, iSpin1);
   kSpin.setArg(2, iSpin);
   kSpin.setArg(3, 1, types.INT);
   cmdQueue.enqueueNDRangeKernel(kSpin, 0, globalWorkSize, null);
   cmdQueue.flush();
  }
  cmdQueue.enqueueNDRangeKernel(kPix, 0, globalWorkSize, null);
  cmdQueue.enqueueReadBuffer (bufPix, true, 0, bufSize, outBuffer);
  cmdQueue.finish();
  draw_gl(n, n, outBuffer);
  frames++;
}
function anim(){
   draw();
   switch ( animation ){
     case "reset":
       initImageSpin();
       animation = "animate";
     case "animate":
       if (delay == 0) requestAnimationFrame(anim);
       else setTimeout("requestAnimationFrame(anim)", delay);
       break;
     case "stop":
       break;
   }
}
function run(v) {
  if( animation == "animate" ){
    animation = "stop";
    document.getElementById('runBtn').value = "Run ";}
  else{
    animation = "animate";
    document.getElementById('runBtn').value = "Stop";
    anim();
  }
}
function reset() {
  if( animation == "stop" ){
    animation = "reset";
    document.getElementById('runBtn').value = "Stop";
    anim();}
  else animation = "reset";
}
function setDelay(val) {
  delay = parseInt(val);
}
function fr(){
  var ti = new Date().getTime();
  var fps = Math.round(1000*frames/(ti - time));
  document.getElementById("framerate").value = fps;
  frames = 0;  time = ti;
}
function setT(v){
  var T = v.valueOf();
  var w = new Float32Array(5);
  for(var i = 0; i < 5; i++)
    w[i] = 4294967295/(1 + Math.exp(2*(2*i - 4)/T));
  cmdQueue.enqueueWriteBuffer(bufW, true, 0, bufWSize, w);
}
function setIt(val) {
  it = parseInt(val);
}
</script>
<style type="text/css">
  H1{ font-size: 120%; color: green}
  H2{ font-size: 100%; color: green}
  pre{ color: darkblue}
</style>
</head><body onload="CL_rand ()">

<h1>Ising model</h1>

<p id="output"></p>
<canvas id="c" width="512" height="512"></canvas>
<br><button onclick="reset()">Reset</button>
<input type="button" onclick="run()" value="Stop" size="1" id="runBtn">
T<input size="3" value="1" onchange="setT( this.value )">
It<input size="1" value="100" onchange="setIt( this.value )">
delay<input size="2" value="0" onchange="setDelay( this.value )">
fps<input size="2" id="framerate">

<p>Monte-Carlo simulation of the Ising model on the square 512&times;512
grid. <i>it</i> is the number of MC iterations per frame. The thermostat
algorithm and linear congruential random number generator are used.

</body></html>
